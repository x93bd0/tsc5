#include "imports/stdlib.fc";
forall X -> tuple siv(tuple t, X value, int position) asm "SETINDEXVAR";
forall X -> (tuple) to_tuple (X x) asm "NOP";

const   MASK = 0xffff;
const  MASK4 = 15;
const MASK10 = 2047;
const MASK64 = 0xffffffffffffffff;
const  QLMAX = 5865;
const    BIC = 11;
const    EBI = 23;

(int)
make (int d, int p, int x, int f)
inline
{
  return (f << 48) + (x << 32) + (p << 16) + d;
}

(int, int, int, int)
unmakef (int v)
inline
{
  return (v & MASK, (v >> 16) & MASK, (v >> 32) & MASK, (v >> 48) & MASK);
}

(int, int, int)
unmake (int v) 
inline
{
  return (v & MASK, (v >> 16) & MASK, (v >> 32) & MASK);
}

(int, tuple) qlilo_push(tuple q, int E, int V)
{
  int K = E % QLMAX;
  tuple qchild = K == 0 ? empty_tuple() : q.at(E / QLMAX);

  int SubI = K / EBI;
  int IntI = K % EBI;

  int TV = 0;
  if (IntI > 0)
  {
    TV = qchild.at(SubI);
  }

  int R = (TV - (((TV >> (IntI * BIC)) & MASK10) << (IntI * BIC))) + (V << (IntI * BIC));

  if (IntI > 0)
  {
    qchild = siv(qchild, R, SubI);
  } else {
    qchild~tpush(R);
  }

  if (K == 0)
  {
    q~tpush(qchild);
    return (E + 1, q);
  }
  return (E + 1, siv(q, qchild, E / QLMAX));
}

(int, int) qlilo_pop
(tuple q, int S)
{
  tuple qchild = q.at(S / QLMAX);
  int K = S % QLMAX;
  int SubI = K / EBI;
  int IntI = K % EBI;
  return (S + 1, (qchild.at(SubI) & (MASK10 << (BIC * IntI))) >> (BIC * IntI));
}

(int) qlilo_empty?(int S, int E)
{
  return E <= S;
}


(tuple) matrix_edit(tuple mat, int i, int V)
inline
{
  int TV = mat.at(i / 4);
  int sI = i % 4;

  TV = (TV - (((TV >> (sI * 64)) & MASK64) << (sI * 64))) + (V << (sI * 64));
  return siv(mat, TV, i / 4);
}

(int) matrix_read(tuple mat, int i)
{
  int IntI = i % 4;
  return (mat.at(i / 4) & (MASK64 << (64 * IntI))) >> (64 * IntI);
}



(int, int, int, tuple)
solve(int n, int m, tuple maze)
method_id
{

  tuple ql = empty_tuple();
  tuple tf = empty_tuple();
  repeat (255) { tf~tpush(0); }
  int i = 0; int flag = 0;
  int sx = 0; int sy = 0;
  int ex = 0; int ey = 0;

  while (i < n) & (flag < 2)
  {
    tuple t = maze.at(i);
    int j = 0;

    while (j < m) & (flag < 2)
    {
      if (t.at(j) == 83)
      {
        sx = j; sy = i;
        flag += 1;
      } elseif (t.at(j) == 69)
      {
        ex = j; ey = i;
        flag += 1;
      }

      j += 1;
    } i += 1;
  }

  int S = 0; int E = 0;
  (E, ql) = qlilo_push(ql, E, sy * m + sx);
  tf = matrix_edit(tf, sy * m + sx, make(1, 0, 0, 0));

  while ~(qlilo_empty?(S, E))
  {
    (S, int i) = qlilo_pop(ql, S);
    int ix = i % m; int iy = i / m;
    int x = matrix_read(tf, i);
    (int xd, int xp, int xx) = unmake(x);

    int l = -1;
    while (l < 2)
    { int r = -1;
      while (r < 2)
      {
        if (~((r == l) & (r == 0))) &
            (l + ix >= 0) &
            (l + ix <  m) &
            (r + iy >= 0) &
            (r + iy <  n)
        {
          int u = matrix_read(tf, (r + iy) * m + (l + ix));
          (int ud, int up, int ux) = unmake(u);

          int pos = maze.at(r + iy).at(l + ix);
          int ext = pos == 63 ? 1 : 0;
          int ext2 = pos == 88 ? 1 : 0;

          if (ud == 0)
          {
            tf = matrix_edit(tf, (r + iy) * m + (l + ix), make(xd + 1, xp + ext, xx + ext2, iy * m + ix));
            (E, ql) = qlilo_push(ql, E, (r + iy) * m + (l + ix));
          }
          elseif (xx + ext2 < ux)
          {
            tf = matrix_edit(tf, (r + iy) * m + (l + ix), make(xd + 1, xp + ext, xx + ext2, iy * m + ix));
            (E, ql) = qlilo_push(ql, E, (r + iy) * m + (l + ix));
          } elseif (xx + ext2 == ux)
          {
            if (xp + ext < up)
            {
              tf = matrix_edit(tf, (r + iy) * m + (l + ix), make(xd + 1, xp + ext, xx + ext2, iy * m + ix));
              (E, ql) = qlilo_push(ql, E, (r + iy) * m + (l + ix));
            } elseif (xp + ext == up) & (xd + 1 < up)
            {
              tf = matrix_edit(tf, (r + iy) * m + (l + ix), make(xd + 1, xp + ext, xx + ext2, iy * m + ix));
              (E, ql) = qlilo_push(ql, E, (r + iy) * m + (l + ix));
            }
          }
        } r += 1;
      } l += 1;
    }
  }

  int raw = matrix_read(tf, ey * m + ex);
  (int d, int p, int x, int f) = unmakef(raw);

  int td = d;
  while (td > 2)
  {
    int xi = f % m; int yi = f / m;
    maze = siv(maze, siv(maze.at(yi), 33, xi), yi);
    int temp = matrix_read(tf, f);
    (td, f) = (temp & MASK, (temp >> 48) & MASK);
  }

  return (x, p, d - 1, maze);
}

;; UNOPTIMIZED CODE
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  
}
