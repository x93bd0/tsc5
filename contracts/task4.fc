#include "imports/stdlib.fc";

const MASK = 0xffff;
const MASK64 = 0xffffffffffffffff;

forall X -> (tuple) to_tuple (X x) asm "NOP";
forall X -> tuple siv(tuple t, X value, int position) asm "SETINDEXVAR";
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  
}

(tuple)
edit(tuple input, int i, int v)
impure inline
asm """
  // (in, i, v)
  SWAP            // (in, v, i)
  8 PUSHPOW2DEC   // (in, v, i, 255)
  DIVMOD          // (in, v, i / 255, i % 255)
  s3 s1 PUSH2     // (in, v, i / 255, i % 255, in, i / 255)
  INDEXVAR        // (in, v, i / 255, i % 255, st)
  -ROT            // (in, v, st, i / 255, i % 255)
  s1 s3 XCHG      // (in, i / 255, st, v, i % 255)
  SETINDEXVAR     // (in, i / 255, st)
  SWAP            // (in, st, i / 255)
  SETINDEXVAR     // (out)
""";

(int)
read(tuple input, int i)
inline
asm """
  // (in, i)
  8 PUSHPOW2DEC   // (in, i, 255)
  DIVMOD          // (in, i / 255, i % 255)
  -ROT            // (i % 255, in, i / 255)
  INDEXVAR        // (i % 255, st)
  SWAP            // (st, i % 255)
  INDEXVAR        // (val)
""";


(int, int, int, tuple)
solve (int n, int m, tuple maze) method_id
{
  set_gas_limit(1000000000);
  int ts = n * m;
  tuple tf = empty_tuple();

  repeat ((ts / 255) + 1)
  {
    tuple temp = empty_tuple();
    repeat (min(ts, 255))
    {
      temp~tpush(MASK64);
    }

    ts -= 255;
    tf~tpush(temp);
  }

  int i = 0; int flag = 0;
  int sx = 0; int sy = 0;
  int ex = 0; int ey = 0;

  while (i < n) & (flag < 2)
  {
    tuple t = maze.at(i);
    int j = 0;

    while (j < m) & (flag < 2)
    {
      if (t.at(j) == 83)
      {
        sx = j; sy = i;
        flag += 1;
      } elseif (t.at(j) == 69)
      {
        ex = j; ey = i;
        flag += 1;
      }

      j += 1;
    } i += 1;
  }

  tf = edit(tf, sy * m + sx, 0);
  int S = 1;

  while (S > 0)
  {
    S = 0;
    int Val = MASK64;
    int x = 0;
    int i = 0;

    while (i < n * m)
    {
      int v = read(tf, i);
      if (v < MASK64)
      { S += 1; }
      if (Val > v)
      {
        Val = v;
        x = i;
      } i += 1;
    }

    if (Val < MASK64)
    {
      int iy = x / m; int ix = x % m;
      tf = edit(tf, x, Val + (1 << 65));

      int l = -1;
      while (l < 2)
      {
        int r = -1;
        while (r < 2)
        {
          if (~((r == l) & (r == 0))) &
              (l + ix <  m) &
              (l + ix >= 0) &
              (r + iy >= 0) &
              (r + iy <  n)
          {
            int pos = maze.at(iy + r).at(ix + l);
            int path = r * m + l + x;
            int w = Val + (1 << 16) + ((pos == 63 ? 1 : 0) << 32) + ((pos == 88 ? 1 : 0) << 48);

            if (w < (read(tf, path) & MASK64))
            {
              tf = edit(tf, path, (w & ~(MASK)) + x);
            }
          } r += 1;
        } l += 1;
      }
    }
  }

  int raw = read(tf, ey * m + ex);
  (int d, int p, int x, int f) = ((raw >> 16) & MASK, (raw >> 32) & MASK, (raw >> 48) & MASK, raw & MASK);

  int td = d;
  do {
    int xi = f % m; int yi = f / m;
    maze = siv(maze, siv(maze.at(yi), 33, xi), yi);
    int temp = read(tf, f);
    (td, f) = ((temp >> 16) & MASK, temp & MASK);
  } until (3 > td)

  return (x, p, d - 1, maze);
}
