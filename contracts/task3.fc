#include "imports/stdlib.fc";

int cell_null?(cell c) asm "ISNULL";
(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "NULLSWAPIFNOT";
int slice_empty?(slice s) asm "SEMPTY";


;; <<<<< Custom version-specific code begins
;; Custom version-specific code ends >>>>>

(int, cell) load_storage() {
  slice cs = get_data().begin_parse();
  return (cs~load_uint(32), cs~load_ref());
}

cell get_storage() {
  (_, cell st) = load_storage();
  return st;
}

cell wrap_storage(int version_id, cell storage) {
  return begin_cell()
    .store_uint(version_id, 32)
    .store_ref(storage)
  .end_cell();
}

int version() method_id {
  slice cs = get_data().begin_parse();
  return cs~load_uint(32);
}

() recv_internal(int msg_value, int balance, cell in_msg_full, slice in_msg_body) impure {
  int ev = in_msg_body~load_uint(32);
  if (ev == 0)
  {
    set_data(wrap_storage(1, begin_cell().end_cell()));
    return ();
  }

  (int ver, cell st) = load_storage();
  int av = in_msg_body.preload_uint(1);
  (cell ec, cell mig, cell pl) = (
    in_msg_body~load_maybe_ref(), in_msg_body~load_dict(), in_msg_body~load_ref());

  int f = 0;
  while (ev > ver)
  {
    f = 1;

    (slice val, int fl) = udict_get?(mig, 32, ver);
    if (fl == 0)
    { throw(400); }

    ver = val~load_uint(32);
    cell ref = val~load_maybe_ref();

    if ~(cell_null?(ref))
    {
      set_code(ref);
      set_c3(ref.begin_parse().bless());
      st = migrate_one(st);
      set_data(wrap_storage(ver, st));
    }
  }

  if (ver != ev)
  { throw(400); }

  if (f)
  {
    if ~ (av)
    { throw(200); }
    cont val = ec.begin_parse().bless();
    set_code(ec); set_c3(val);
  }

  set_data(wrap_storage(ver, st));
  st = process_message(
    st, msg_value, balance, in_msg_full, pl.begin_parse());
  set_data(wrap_storage(ver, st));
}
