#include "imports/stdlib.fc"

() recv_internal(int msg_value, int balance, cell in_msg_full, slice in_msg_body) impure {
  int ev = in_msg_body~load_uint(32);
  cell new_code = in_msg_body~load_maybe_ref();
  cell migrations = in_msg_body~load_dict();
  cell payload = in_msg_body~load_cell();

  if (ev == 0)
  {
    storage = get_storage();
    wrap_storage(storage, 0);
    return ();
  }

  process_message(get_storage(), msg_value, balance, in_msg_full, in_msg_body);
}

cell get_storage() {
  slice cs = get_data().begin_parse();
  cell storage = cs~load_ref();
  return storage;
}

cell wrap_storage(int version_id, cell storage) {
  return begin_cell()
    .store_uint(version_id)
    .store_ref(storage)
  .end_cell();
}

int version() method_id {
  return get_data().begin_parse().load_uint(32);
}

;; <<<<< Custom version-specific code begins
;; This section (everything between << and >> characters) will be fully substituted for each version.
;; This is an IMPORTANT part, and these exact lines with <<<<< and >>>>> must be present in your code for the testing system to work correctly.
;; All the code provided here serves as an example of the version-code, which your update code must be compatible with.
;; Refer to the "3-example" directory for more version examples.

;; from counter-v0.fc
cell process_message(cell storage, int msg_value, int balance, cell in_msg_full, slice in_msg_body) impure {
    slice cs = storage.begin_parse();
    int current_amount = cs.preload_uint(32);
    return begin_cell().store_uint(current_amount + 1, 32).end_cell();
}

cell migrate_one(cell old_storage) { ;; it's just a placeholder that is required for correct compilation
    return old_storage;
}

;; Custom version-specific code ends >>>>>
