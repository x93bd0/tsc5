#include "imports/stdlib.fc";
forall X -> tuple siv(tuple t, X value, int position) asm "SETINDEXVAR";
(int) tlen (tuple t) asm "TLEN";
const IB = 36893488147419103231;

(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "NULLSWAPIFNOT";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  
}

() mt(tuple m, int i,
                int v1, int v2)
impure inline { ;; can fail
  tuple um = m.at(i / 255);
  um = siv(
    um, (v1 << 32) + v2, i % 255);
  siv(m, um, i / 255);
}


(int, int)
rt(tuple m, int i) impure inline
{
  int r = m.at(i / 255).at(i % 255);
  int v2 = r & 0xffffffff;
  return (r >> 32, v2);
}

(int, int, int)
tpm(tuple queue, int s, int e, int c, int val) impure inline
{
  if (queue.tlen() != 255)
  { queue~tpush(val); }
  else { siv(queue, val, e); }
  if (e == 254) { e = 0; }
  else { e += 1; }
  return (s, e, c + 1);
}

(int, int, int)
tpp(tuple queue, int s, int c) impure inline
{
  int v = queue.at(s);
  if (s == 254)
  { return (0, c - 1, v); }
  return (s + 1, c - 1, v);
}

(int, int, int, tuple)
solve (int n, int m, tuple maze) method_id
{
{-
  int ts = n * m;
  tuple ft = empty_tuple();
  repeat ((ts / 255) + 1)
  {
    tuple e = empty_tuple();
    repeat (255) {
      e~tpush(IB);
    }
    ft~tpush(e);
  }

  ;; two pointer queue
  tuple queue = empty_tuple();
  int s = 0; int e = 0; int c = 0;
  int sx = 0; int sy = 0;
  int i = n - 1;
  int flag = 0;

  while (i >= 0) & (flag == 0)
  {
    slice te = maze.at(i);
    int j = 0;

    while (j < m) & (flag = 0) {
      if (te~load_uint(8) == 83)
      {
        flag = 1;
        sx = j; sy = i;
      }

      j += 1;
    }

    i -= 1;
  }

  (s, e, c) = tpm(queue, s, e, c, ((sy * n) + sx) << 32);
  while (c > 0)
  {
    (s, c, int raw) = tpp(queue, s, c);
    int d = raw & 0xffff;
    int p = (raw >> 16) & 0xffff;
    int r2 = raw >> 32;
    int sy = r2 / n; int sx = r2 % n;

    int i = -1;

    while (i != 2) {
      int j = -1;
      while (j != 2) {
        ifnot (i == 0) & (j == 0) {
          if (i + sx >= 0) & (i + sx < n) & (j + sy >= 0) & (j + sy < m) {
            (s, e, c) = tpm(queue, s, e, c, (((j + sy) * n) + (sx + i)) << 32 + (p << 16) + (d + 1));
          }
        }
        j += 1;
      }
      i += 1;
    }
  }

  -}
  return (-1, 0, 0, null());
}
